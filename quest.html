<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Вашият Път към Здравето Започва Тук</title>
  
  <!-- Оригинални CSS файлове за съвместимост -->
  <link href="css/quest_styles.css" rel="stylesheet">
  <link href="css/components_styles.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">

  <!-- =================================================================== -->
  <!-- === НОВИ, ПОДОБРЕНИ СТИЛОВЕ (ВГРАДЕНИ ЗА ЛЕСНА ИНТЕГРАЦИЯ) === -->
  <!-- =================================================================== -->
  <style>
    /* 
      Част 1: Основни стилове за съвместимост.
      Тези стилове се зареждат от quest_styles.css, но тук дефинираме
      промените за новия начален екран.
    */

    /* Анимация за финия, бавен фон */
    @keyframes subtleGradient {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    /* Стил за контейнера на новия начален екран */
    #page0.hero-start-page {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100dvh; /* Използваме dvh за по-добра съвместимост с мобилни браузъри */
      display: flex;
      justify-content: center;
      align-items: center;
      color: #ffffff;
      
      /* По-изтънчен, тъмен и бавен градиент */
      background: linear-gradient(-45deg, #0a0a0a, #121212, #00201a, #101010);
      background-size: 400% 400%;
      animation: subtleGradient 25s ease infinite;
    }

    /* Нулиране на стиловете от .container, когато е на началната страница */
    .hero-start-page .container {
        background: transparent;
        box-shadow: none;
        padding: 0;
        margin: 0;
        max-width: 1000px;
    }

    /* Контейнер за съдържанието, което се появява с анимация */
    .hero-content {
      text-align: center;
      padding: 20px;
      opacity: 0;
      transform: translateY(15px);
      animation: fadeInHero 1.2s cubic-bezier(0.19, 1, 0.22, 1) 0.5s forwards;
    }

    @keyframes fadeInHero {
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    /* Основно заглавие - по-голямо, по-въздействащо */
    .hero-title {
      font-size: 3rem;
      font-weight: 800;
      color: #fff;
      line-height: 1.2;
      min-height: 140px; /* Резервираме място, за да не "скача" лейаута */
      margin-bottom: 3rem;
      text-shadow: 0 0 15px rgba(79, 195, 161, 0.3); /* Фин блясък */
    }

    .hero-title .typewriter-cursor {
      display: inline-block;
      width: 4px;
      height: 3rem;
      background-color: #4fc3a1;
      animation: blink 0.8s infinite;
      vertical-align: bottom;
      margin-left: 2px;
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0; }
    }
    
    /* Бутон за действие (CTA) - централен фокус */
    .hero-start-page #startBtn {
      background: #4fc3a1;
      color: #121212;
      font-size: 1.25rem;
      font-weight: bold;
      padding: 18px 50px;
      border-radius: 50px;
      border: none;
      cursor: pointer;
      position: relative;
      
      /* По-плавни преходи и по-силен "glow" ефект */
      transition: transform 0.3s cubic-bezier(0.19, 1, 0.22, 1), box-shadow 0.3s cubic-bezier(0.19, 1, 0.22, 1);
      box-shadow: 0 0 25px rgba(79, 195, 161, 0.4);
    }

    .hero-start-page #startBtn:hover {
      transform: translateY(-5px) scale(1.05);
      box-shadow: 0 0 40px rgba(79, 195, 161, 0.6);
    }
    
    /* Адаптации за мобилни устройства */
    @media (max-width: 768px) {
      .hero-title {
        font-size: 2.2rem;
        min-height: 110px;
      }
      .hero-title .typewriter-cursor {
        height: 2.2rem;
      }
      .hero-start-page #startBtn {
        font-size: 1.1rem;
        width: 90%;
        padding: 18px 20px;
      }
    }
  </style>
</head>
<body>

<!-- Прогрес барът и другите елементи остават непроменени и ще се появят на следващите страници -->
<div class="step-indicator-container">
  <span class="step-indicator-label">Стъпка <span id="questCurrentStep">0</span> от <span id="questTotalSteps">0</span></span>
  <div class="progress-bar-steps"><div id="questProgressBar" class="step-progress-bar"></div></div>
</div>

<div class="container" id="dynamicContainer">
  <!-- Динамично генерираните "страници" ще се вмъкнат тук -->
</div>

<!-- Тайни зони и бутони (остават непроменени) -->
<div id="secretTapArea" style="position: fixed; top: 0; left: 0; width: 30px; height: 30px; opacity: 0; z-index: 9999;"></div>
<a href="admin.html" id="adminLink" style="display:none; position: fixed; bottom: 10px; right: 10px; background: #4fc3a1; color: #121212; padding: 5px 10px; border-radius: 5px; text-decoration: none;">Admin</a>

<script type="module">
  // Всички съществуващи import-и и променливи остават непроменени
  import { workerBaseUrl } from './js/config.js';
  import { setupRegistration } from "./js/register.js";
  import { showMessage, hideMessage } from "./js/messageUtils.js";
  import { updateStepProgress } from "./js/stepProgress.js";

  /***** Глобални променливи (непроменени) *****/
  let rawQuestions = [];
  let flatPages = [];
  let currentPageIndex = 0;
  let totalPages = 0;
  let registrationPageIndex = 0;
  const responses = {};
  const numericRanges = {
    age: { min: 10, max: 120 }, height: { min: 100, max: 250 }, weight: { min: 30, max: 300 }, lossKg: { min: 1, max: 100 }, q1745847247058: { min: 1, max: 300 }, q1745847190198: { min: 1, max: 300 }, q1745847315231: { min: 1, max: 300 }
  };
  
  // === НАЧАЛО: САМОСТОЯТЕЛЕН СКРИПТ ЗА TYPEWRITER ЕФЕКТ ===
  function setupTypewriter(element, texts, wait = 2500, typeSpeed = 100) {
    let textIndex = 0;
    let charIndex = 0;
    let isDeleting = false;
    const cursor = element.querySelector('.typewriter-cursor');

    function type() {
      const currentText = texts[textIndex];
      let speed = isDeleting ? typeSpeed / 2 : typeSpeed;
      
      if (isDeleting) {
        charIndex--;
      } else {
        charIndex++;
      }
      
      element.firstChild.textContent = currentText.substring(0, charIndex);
      if(cursor) element.appendChild(cursor);

      if (!isDeleting && charIndex === currentText.length) {
        speed = wait;
        isDeleting = true;
      } else if (isDeleting && charIndex === 0) {
        isDeleting = false;
        textIndex = (textIndex + 1) % texts.length;
        speed = 500;
      }

      setTimeout(type, speed);
    }
    
    if (texts && texts.length > 0) {
        type();
    }
  }
  // === КРАЙ: СКРИПТ ЗА TYPEWRITER ЕФЕКТ ===


  /***** Функция за изграждане на страниците (непроменена) *****/
  function buildDynamicPages() {
    const container = document.getElementById('dynamicContainer');
    if (!container) return;
    container.innerHTML = "";

    createStartPage(); // <-- Тази функция е заменена с новата версия
    flatPages = flattenQuestions(rawQuestions).filter(q => q.id !== 'email' && q.type !== 'section');

    flatPages.forEach((q, idx) => {
      createQuestionPage(q, idx + 1);
    });
    createRegistrationPage();
    createFinalPage();
    setupFinalPageListener();

    totalPages = 1 + flatPages.length + 2;
    updateStepProgress(
      document.getElementById('questProgressBar'), 0, totalPages - 1,
      document.getElementById('questCurrentStep'), document.getElementById('questTotalSteps')
    );
    showPage(0);
  }

  // === НАЧАЛО: ИЗЦЯЛО НОВА, ПОДОБРЕНА ФУНКЦИЯ ЗА НАЧАЛНА СТРАНИЦА ===
  /***** Създаване на стартова страница (ПОДОБРЕНА ВЕРСИЯ) *****/
  function createStartPage() {
    const container = document.getElementById('dynamicContainer');
    if (!container) return;
    const pageDiv = document.createElement('div');
    // Добавяме специален клас, за да активираме новите стилове
    pageDiv.className = 'page hero-start-page'; 
    pageDiv.id = 'page0';

    // Минималистичен и силно въздействащ HTML
    pageDiv.innerHTML = `
      <div class="hero-content">
        <h1 class="hero-title">
          <span></span><span class="typewriter-cursor"></span>
        </h1>
        <div class="cta-container">
          <button type="button" id="startBtn">Започни</button>
        </div>
      </div>
    `;
    container.appendChild(pageDiv);
    
    // Активираме Typewriter ефекта с новите, по-силни послания
    const typewriterElement = pageDiv.querySelector('.hero-title');
    if(typewriterElement) {
        const textsToType = [
            "Твоята промяна започва сега.",
            "Наука, създадена за теб.",
            "Отключи пълния си потенциал."
        ];
        setupTypewriter(typewriterElement, textsToType);
    }

    // Логиката за бутона остава същата, за да работи безпроблемно с Вашата система
    const startBtn = pageDiv.querySelector('#startBtn');
    if (startBtn) {
        startBtn.addEventListener('click', () => {
          console.log("Новият бутон 'Започни' е натиснат.");
          // КРИТИЧНО: Премахваме специалния клас, за да се върнат нормалните стилове
          pageDiv.classList.remove('hero-start-page');
          showPage(1); // Преминаваме към първия въпрос
        });
    } else {
        console.error("Start button not found on the new hero start page.");
    }
  }
  // === КРАЙ: НОВА ФУНКЦИЯ ЗА СТАРТОВА СТРАНИЦА ===


  // =============================================================
  // ... ТУК СЛЕДВА ОСТАНАЛАТА ЧАСТ ОТ ВАШИЯ ОРИГИНАЛЕН JAVASCRIPT КОД ...
  // КОПИРАЙТЕ И ПОСТАВЕТЕ ВСИЧКО ОТ `flattenQuestions` НАДОЛУ БЕЗ ПРОМЯНА.
  // За краткост, кодът тук е съкратен, но във вашия файл той трябва да присъства.
  // =============================================================
  
    /***** Функция за рекурсивно сплескване на въпросите (непроменена) *****/
    function flattenQuestions(questions) {
    let output = [];
    questions.forEach(q => {
      let qCopy = Object.assign({}, q);
      delete qCopy.children;
      if (qCopy.type !== 'section') {
        output.push(qCopy);
      }
      if (q.children && Array.isArray(q.children)) {
        output = output.concat(flattenQuestions(q.children));
      } else if (q.children && typeof q.children === 'object') {
        for (const answer in q.children) {
          let childArray = q.children[answer];
          if (Array.isArray(childArray)) {
             childArray.forEach(child => {
                child.dependency = { question: q.id, value: answer };
             });
             output = output.concat(flattenQuestions(childArray));
          } else {
             console.warn(`Expected an array for children under key '${answer}' in question '${q.id}', but got:`, typeof childArray);
          }
        }
      }
    });
    return output;
  }

  /***** Създаване на страница за всеки въпрос (непроменена) *****/
  function createQuestionPage(question, pageIndex) {
    const container = document.getElementById('dynamicContainer');
     if (!container || !question || !question.id) {
         console.error("Missing container or question data for page", pageIndex);
         return;
     };
    const pageDiv = document.createElement('div');
    pageDiv.className = 'page';
    pageDiv.id = 'page' + pageIndex;
    let html = '';
    if (question.type === 'section') {
      html += `<div class="section-title">${question.sectionTitle || question.text || ''}</div>`;
    } else {
      html += `<div class="question-text">${question.text || 'Липсва текст на въпроса'}</div>`;
    }

    const isRequired = false;

    if (question.type === 'section') {
    } else if (['text','number','email'].includes(question.type)) {
      const range = numericRanges[question.id];
      const rangeAttrs = (question.type === 'number' && range) ? `min="${range.min}" max="${range.max}"` : '';
      html += `<input id="${question.id}" type="${question.type}" placeholder="" ${rangeAttrs} ${isRequired ? 'required' : ''} ${question.type === 'email' ? 'autocomplete="email"' : ''}>`;
    } else if (question.type === 'textarea') {
      html += `<textarea id="${question.id}" rows="4" ${isRequired ? 'required' : ''}></textarea>`;
    } else if (question.type === 'select') {
      html += `<select id="${question.id}" ${isRequired ? 'required' : ''}><option value="">Изберете</option>`;
      (question.options || []).forEach(opt => {
        html += `<option value="${String(opt)}">${String(opt)}</option>`;
      });
      html += `</select>`;
    } else if (question.type === 'radio') {
      (question.options || []).forEach((opt, index) => {
          const optionValue = String(opt);
        html += `<label class="answer-label">
                   <input name="${question.id}" type="radio" value="${optionValue}" ${isRequired && index === 0 ? 'required' : ''}> ${optionValue}
                 </label>`;
      });
    } else if (question.type === 'checkbox') {
      (question.options || []).forEach(opt => {
          const optionValue = String(opt);
        html += `<label class="answer-label">
                   <input name="${question.id}" type="checkbox" value="${optionValue}"> ${optionValue}
                 </label>`;
      });
    } else if (question.type !== 'section') {
        console.warn(`Unsupported question type: ${question.type} for question ID: ${question.id}`);
        html += `<p style="color: red;">Грешка: Неподдържан тип въпрос.</p>`;
    }

    if (question.dependency) {
      html += `<div class="fs-xs text-muted" style="margin-top: 10px;">(Показва се ако '${question.dependency.question}' е '${question.dependency.value}')</div>`;
    }

    html += `<div class="nav-buttons">
               <button type="button" id="nextBtn${pageIndex}">Напред ▶</button>
               ${pageIndex > 1 ? `<button type="button" id="prevBtn${pageIndex}">◀ Назад</button>` : ''}
             </div>`;

    pageDiv.innerHTML = html;
    container.appendChild(pageDiv);

    const nextBtn = pageDiv.querySelector(`#nextBtn${pageIndex}`);
    if (nextBtn) {
        nextBtn.addEventListener('click', () => {
          if (question.type !== 'section' && !validateAnswer(question)) return;
          if (question.type !== 'section') saveAnswer(question);
          showPage(pageIndex + 1);
        });
    }

    const prevBtn = pageDiv.querySelector(`#prevBtn${pageIndex}`);
    if (prevBtn) {
        prevBtn.addEventListener('click', () => {
           if (question.type !== 'section') saveAnswer(question);
           showPage(pageIndex - 1);
        });
    }
  }
  
    /***** Останалите функции остават непроменени... *****/
    // createRegistrationPage, createFinalPage, setupFinalPageListener, showPage,
    // updateProgress, saveProgress, loadProgress, applySavedResponses, clearProgress,
    // saveAnswer, validateAnswer, submitResponses, и DOMContentLoaded listener.
    // Поставете ги тук.
    
  /***** Създаване на страница за регистрация *****/
  function createRegistrationPage() {
    const container = document.getElementById('dynamicContainer');
    if (!container) return;
    const regIndex = flatPages.length + 1;
    registrationPageIndex = regIndex;
    const pageDiv = document.createElement('div');
    pageDiv.className = 'page';
    pageDiv.id = 'page' + regIndex;
    pageDiv.innerHTML = `
      <h2>Регистрация</h2>
      <form id="register-form-q" novalidate>
        <div class="form-group">
          <label for="register-email-q">Имейл:</label>
          <input type="email" id="register-email-q" required autocomplete="email">
        </div>
        <div class="form-group">
          <label for="register-password-q">Парола (мин. 8 знака):</label>
          <input type="password" id="register-password-q" required minlength="8">
        </div>
        <div class="form-group">
          <label for="confirm-password-q">Потвърди Парола:</label>
          <input type="password" id="confirm-password-q" required minlength="8">
        </div>
        <div id="register-message-q" class="message" role="alert"></div>
        <div class="nav-buttons">
          <button type="submit" id="regSubmitBtn">Регистрация</button>
          <button type="button" id="regBackBtn">◀ Назад</button>
        </div>
      </form>
    `;
    container.appendChild(pageDiv);
    const emailInput = pageDiv.querySelector('#register-email-q');
    if (emailInput && responses.email) emailInput.value = responses.email;

    pageDiv.querySelector('#regBackBtn').addEventListener('click', () => {
      showPage(regIndex - 1);
    });
    setupRegistration("#register-form-q", "#register-message-q");
    pageDiv.querySelector("#register-form-q").addEventListener("registrationSuccess", (event) => {
      responses.email = event.detail.email;
      saveProgress();
      showPage(regIndex + 1);
    });

  }

  /***** Създаване на финална страница *****/
  function createFinalPage() {
    const container = document.getElementById('dynamicContainer');
    if (!container) return;
    const finalIndex = flatPages.length + 2;
    const pageDiv = document.createElement('div');
    pageDiv.className = 'page';
    pageDiv.id = 'page' + finalIndex;
    pageDiv.innerHTML = `
      <h2>Поздравления! <i class="bi bi-stars"></i><br> Току що направихте най-важната стъпка по пътя към промяната</h2>
      <p>Натиснете бутона, за да изпратите вашите отговори за обработка.</p>
      <div class="nav-buttons" style="justify-content: center;">
        <button id="submitBtn" type="button">Изпрати</button>
        <button id="finalBackBtn" type="button">◀ Назад</button>
        <button id="restartBtn" type="button">Отначало</button>
      </div>
       <div id="submit-message" class="message" style="margin-top: 15px; text-align: center; font-weight: bold; word-wrap: break-word;"></div>
    `;
    container.appendChild(pageDiv);
  }

   function setupFinalPageListener() {
        const finalIndex = flatPages.length + 2;
        const pageDiv = document.getElementById('page' + finalIndex);
        if (!pageDiv) {
            console.error("Финалната страница не е намерена при настройка на listener.");
            return;
        }
        const submitBtn = pageDiv.querySelector('#submitBtn');
        const restartBtn = pageDiv.querySelector('#restartBtn');
        const backBtn = pageDiv.querySelector('#finalBackBtn');
        const submitMessage = pageDiv.querySelector('#submit-message');

        if (!submitBtn || !restartBtn || !backBtn || !submitMessage) {
             console.error("Един или повече елементи липсват на финалната страница.");
             return;
        }

        restartBtn.addEventListener('click', () => {
            clearProgress();
            location.reload();
        });

        backBtn.addEventListener('click', () => {
            showPage(registrationPageIndex);
        });

        submitBtn.addEventListener('click', async () => {
            submitBtn.disabled = true;
            submitBtn.textContent = 'Изпращане...';
            hideMessage(submitMessage);

            try {
                const result = await submitResponses();

                showMessage(submitMessage, result.message || "Отговорите са изпратени успешно за обработка!", false);
                submitBtn.style.display = "none";
        
                const lastQuestionPageIndex = totalPages - 3; 

                if (lastQuestionPageIndex >= 0) {
                    const backToEditBtn = document.createElement('button');
                    backToEditBtn.textContent = '◀ Назад';
                    backToEditBtn.type = 'button';
                    backToEditBtn.style.marginTop = '15px'; 
                    backToEditBtn.style.backgroundColor = '#f39c12';
                    backToEditBtn.style.color = '#1e1e1e';
                    backToEditBtn.id = 'dynamicBackBtn';

                    backToEditBtn.onclick = () => {
                        if (submitMessage) {
                            hideMessage(submitMessage);
                        }
                        backToEditBtn.remove();

                        if (submitBtn) {
                            submitBtn.style.display = 'block';
                            submitBtn.disabled = false;
                            submitBtn.textContent = 'Изпрати отново'; 
                        }
                        if (restartBtn) {
                            restartBtn.disabled = false;
                        }

                        showPage(lastQuestionPageIndex);
                    };

                    submitMessage.parentNode.insertBefore(backToEditBtn, submitMessage.nextSibling);

                    submitBtn.style.display = "none";
                    restartBtn.disabled = false;
                    restartBtn.textContent = "Започни наново";

                } else {
                    submitBtn.style.display = "none";
                    restartBtn.disabled = false;
                    restartBtn.textContent = "Започни наново";
                }
                restartBtn.textContent = "Попълни отново";

            } catch (error) {
                showMessage(submitMessage, `Грешка: ${error.message || 'Неуспешно изпращане.'}`, true);
                submitBtn.disabled = false; 
                submitBtn.textContent = 'Опитай отново';
            }
        });
   }

  function showPage(index) {
    const pages = document.querySelectorAll('.page');
    if (!pages || pages.length === 0) return;

    if (index > currentPageIndex) { 
        let targetIndex = index;
        while (targetIndex < pages.length - 1) { 
             const question = flatPages[targetIndex - 1];
            if (question && question.dependency) {
                const parentAnswer = responses[question.dependency.question];
                const dependencyValue = question.dependency.value;
                let shouldShow = Array.isArray(parentAnswer) ? parentAnswer.includes(dependencyValue) : parentAnswer === dependencyValue;

                if (!shouldShow) {
                    targetIndex++;
                    continue;
                 }
            }
             break;
         }
         index = targetIndex;
     } else if (index < currentPageIndex) {
         let targetIndex = index;
         while (targetIndex > 0) { 
            const question = flatPages[targetIndex - 1];
             if (question && question.dependency) {
                 const parentAnswer = responses[question.dependency.question];
                 const dependencyValue = question.dependency.value;
                 let shouldShow = Array.isArray(parentAnswer) ? parentAnswer.includes(dependencyValue) : parentAnswer === dependencyValue;
                 if (!shouldShow) {
                     targetIndex--;
                     continue;
                 }
             }
             break;
         }
         index = targetIndex;
     }

    if (index < 0) index = 0;
    if (index >= pages.length) index = pages.length - 1;

     if (currentPageIndex > 0 && currentPageIndex < pages.length -1) {
         const previousQuestion = flatPages[currentPageIndex - 1];
         if (previousQuestion) {
             saveAnswer(previousQuestion);
         }
     }

    currentPageIndex = index;
    pages.forEach((pg, idx) => {
        pg.classList.toggle('active', idx === currentPageIndex);
    });

    const activePage = pages[currentPageIndex];
    if (activePage) {
        const firstInput = activePage.querySelector('input, select, textarea');
        if (firstInput) {
             setTimeout(() => {
                 try { firstInput.focus({ preventScroll: true }); } catch (e) { console.warn("Focus failed:", e); }
             }, 50);
         }
    }

    updateProgress();
  }

  function updateProgress() {
    const progressBar = document.getElementById('questProgressBar');
    const currentLabel = document.getElementById('questCurrentStep');
    const totalLabel = document.getElementById('questTotalSteps');
    if (!progressBar || totalPages <= 1) return;
    const currentStep = currentPageIndex;
    const totalSteps = totalPages - 1;
    updateStepProgress(progressBar, currentStep, totalSteps, currentLabel, totalLabel);
  }

  function saveProgress() {
    try {
      localStorage.setItem('questResponses', JSON.stringify(responses));
      localStorage.setItem('questCurrentPage', String(currentPageIndex));
    } catch (e) {
      console.warn('LocalStorage save failed:', e);
    }
  }

  function loadProgress() {
    try {
      const savedResponses = localStorage.getItem('questResponses');
      const savedPage = localStorage.getItem('questCurrentPage');
      if (savedResponses) Object.assign(responses, JSON.parse(savedResponses));
      if (savedPage) currentPageIndex = parseInt(savedPage, 10) || 0;
    } catch (e) {
      console.warn('LocalStorage load failed:', e);
    }
  }

  function applySavedResponses() {
    for (const [qId, answer] of Object.entries(responses)) {
      const question = flatPages.find(q => q.id === qId);
      if (!question) continue;
      const el = document.getElementById(qId);
      if (['text', 'number', 'email', 'textarea', 'select'].includes(question.type)) {
        if (el) el.value = answer;
      } else if (question.type === 'radio') {
        const radio = document.querySelector(`input[name="${qId}"][value="${answer}"]`);
        if (radio) radio.checked = true;
      } else if (question.type === 'checkbox' && Array.isArray(answer)) {
        answer.forEach(val => {
          const chk = document.querySelector(`input[name="${qId}"][value="${val}"]`);
          if (chk) chk.checked = true;
        });
      }
    }
  }

  function clearProgress() {
    localStorage.removeItem('questResponses');
    localStorage.removeItem('questCurrentPage');
    Object.keys(responses).forEach(key => delete responses[key]);
    currentPageIndex = 0;
  }

  function saveAnswer(question) {
      if (!question || !question.id) return;
      const qId = question.id;
      let answer;
      const el = document.getElementById(qId);
      if (['text', 'number', 'email', 'textarea', 'select'].includes(question.type)) {
        answer = el ? el.value.trim() : undefined;
      } else if (question.type === 'radio') {
        const checked = document.querySelector(`input[name="${qId}"]:checked`);
        answer = checked ? checked.value : null;
      } else if (question.type === 'checkbox') {
        answer = Array.from(document.querySelectorAll(`input[name="${qId}"]:checked`)).map(ch => ch.value);
      }
      if (answer !== undefined) {
        responses[qId] = answer;
        saveProgress();
      }
  }

  function validateAnswer(question) {
    if (!question || !question.id) return true;
    const qId = question.id;
    let isValid = true;
    let errorMessage = '';
    const el = document.getElementById(qId);
    const requiredFields = ['name','gender','age','height','weight','goal','motivation'];
    const isRequired = requiredFields.includes(qId);
    let value = el ? el.value.trim() : '';

    if (isRequired) {
        if (question.type === 'radio' && !document.querySelector(`input[name="${qId}"]:checked`)) {
            isValid = false;
            errorMessage = "Моля, изберете опция.";
        } else if (question.type === 'checkbox' && document.querySelectorAll(`input[name="${qId}"]:checked`).length === 0) {
            isValid = false;
            errorMessage = "Моля, изберете поне една опция.";
        } else if (!value) {
            isValid = false;
            errorMessage = "Моля, попълнете това поле.";
        }
    }
    
    if (isValid && question.type === 'number' && value) {
        const num = Number(value);
        const range = numericRanges[qId];
        if (isNaN(num)) {
            isValid = false; errorMessage = "Моля, въведете валидно число.";
        } else if (range && (num < range.min || num > range.max)) {
            isValid = false; errorMessage = `Стойността трябва да е между ${range.min} и ${range.max}.`;
        }
    }

    let errorElement = document.getElementById(`error-${qId}`);
    if (!isValid) {
        if (!errorElement) {
            errorElement = document.createElement('div');
            errorElement.id = `error-${qId}`;
            errorElement.className = 'validation-error';
            errorElement.style.cssText = "color: #e74c3c; font-size: 0.9em; margin-top: 5px;";
            const page = el.closest('.page');
            page?.querySelector('.nav-buttons')?.before(errorElement);
        }
        errorElement.textContent = errorMessage;
    } else if (errorElement) {
        errorElement.remove();
    }
    return isValid;
  }

  async function submitResponses() {
      responses.submissionDate = new Date().toISOString();
      responses.email = String(responses.email || document.getElementById('register-email-q')?.value || '').trim().toLowerCase();
      
       try {
            const res = await fetch(`${workerBaseUrl}/api/submitQuestionnaire`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(responses)
            });
            const data = await res.json();
            if (!res.ok) throw new Error(data.message || `Грешка от сървъра: ${res.status}`);
            return data;
        } catch (error) {
             console.error("Грешка при изпращане:", error);
             throw error;
        }
  }

   document.addEventListener('DOMContentLoaded', () => {
     fetch('questions.json')
       .then(res => {
         if (!res.ok) throw new Error(`HTTP ${res.status}`);
         const contentType = res.headers.get("content-type");
         if (!contentType || !contentType.includes("application/json")) {
             throw new TypeError(`Очакван JSON, но получен ${contentType}`);
         }
         return res.json();
       })
       .then(data => {
         if (!Array.isArray(data) || data.length === 0) {
            throw new Error("questions.json е празен или невалиден.");
         }
         rawQuestions = data;
         buildDynamicPages();
         loadProgress();
         applySavedResponses();
         showPage(currentPageIndex);
       })
       .catch(err => {
           console.error('Критична грешка при зареждане на въпросника:', err);
           const container = document.getElementById('dynamicContainer');
           if (container) {
                container.innerHTML = `<div style="color: #e74c3c; text-align: center; padding: 20px;">Възникна грешка при зареждане на въпросника. Моля, опитайте да презаредите страницата. (${err.message})</div>`;
           }
        });

       const secretArea = document.getElementById('secretTapArea');
       const adminLink = document.getElementById('adminLink');
       if(secretArea && adminLink) {
           secretArea.addEventListener('click', () => {
             adminLink.style.display = 'block';
             setTimeout(() => { adminLink.style.display = 'none'; }, 10000);
           });
       }
   });

</script>

</body>
</html>
